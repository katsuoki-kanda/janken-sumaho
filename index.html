<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Janken Game Lite - Mobile v4.0</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body { 
            font-family: sans-serif; 
            background: #000; 
            margin: 0; padding: 0;
            height: 100dvh; width: 100vw;
            overflow: hidden; 
            display: flex; flex-direction: column;
        }
        
        #game-container { display: flex; flex-direction: column; width: 100%; height: 100%; }

        #prompt-window { 
            flex: 1; background: white; 
            display: flex; justify-content: center; align-items: center; 
            position: relative; border-bottom: 2px solid #444;
        }

        #prompt-img { max-width: 80%; max-height: 80%; object-fit: contain; }

        .camera-window { 
            background: #000; position: relative; 
            width: 100%; aspect-ratio: 4 / 3;
            overflow: hidden;
        }

        /* ビデオは非表示に設定 */
        video { display: none; }
        
        canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            transform: scaleX(-1); background: #000;
        }
        
        #ui-overlay { 
            position: absolute; top: 10px; right: 15px; 
            color: #0f0; font-size: clamp(24px, 8vw, 40px); 
            text-shadow: 2px 2px #000; z-index: 10; 
            text-align: right; pointer-events: none;
        }

        #status-display { font-size: 0.7em; color: #0ff; }
        
        #center-msg { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            color: #ff00ff; font-size: 40px; font-weight: bold; 
            text-align: center; z-index: 20; width: 100%; pointer-events: none;
            text-shadow: 2px 2px 4px #000;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="prompt-window">
        <img id="prompt-img" src="0.jpg" alt="Instruction">
        <div id="center-msg">HAND UP TO START</div>
    </div>

    <div class="camera-window">
        <video id="input_video" playsinline muted></video>
        <canvas id="output_canvas"></canvas>
        <div id="ui-overlay">
            <div id="score-display">Score: 0</div>
            <div id="timer-display" style="color: #f22;">Time: 60</div>
            <div id="status-display">---</div>
        </div>
    </div>
</div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    // alpha: falseで描画を高速化
    const canvasCtx = canvasElement.getContext('2d', {alpha: false});
    const promptImg = document.getElementById('prompt-img');
    const scoreText = document.getElementById('score-display');
    const timerText = document.getElementById('timer-display');
    const statusText = document.getElementById('status-display');
    const centerMsg = document.getElementById('center-msg');

    let score = 0, timeLeft = 60, gameStarted = false;
    let isReadyToStart = false, currentTask = 0, previousTaskType = -1; 
    let lastHandState = -1, gameTimer = null, isProcessingCorrect = false;
    let isPostGameDelay = false, audioCtx = null;

    // 軽量描画用の骨格定義
    const HAND_LINES = [
        [0,1,2,3,4], [0,5,6,7,8], [9,10,11,12], [13,14,15,16], [17,18,19,20], [0,17], [5,9,13,17]
    ];

    function speak(text) {
        if (!window.speechSynthesis) return;
        window.speechSynthesis.cancel();
        const uttr = new SpeechSynthesisUtterance(text);
        uttr.lang = 'ja-JP';
        window.speechSynthesis.speak(uttr);
    }

    function playBeep() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.frequency.setValueAtTime(880, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.start(); osc.stop(audioCtx.currentTime + 0.1);
    }

    function getTaskType(num) {
        if (num <= 3) return 1; // パー
        if (num >= 4 && num <= 6) return 2; // チョキ
        return 3; // グー
    }

    function nextQuestion() {
        if (!gameStarted) return;
        let nextT, nextType;
        do {
            nextT = Math.floor(Math.random() * 9) + 1;
            nextType = getTaskType(nextT);
        } while (nextType === previousTaskType);
        currentTask = nextT;
        previousTaskType = nextType;
        promptImg.src = `${currentTask}.jpg`;
    }

    // 自前の軽量描画関数（赤丸なし・線のみ）
    function drawSkeleton(landmarks) {
        canvasCtx.strokeStyle = '#0f0';
        canvasCtx.lineWidth = 3;
        const w = canvasElement.width;
        const h = canvasElement.height;
        for (const path of HAND_LINES) {
            canvasCtx.beginPath();
            for (let i = 0; i < path.length; i++) {
                const pt = landmarks[path[i]];
                if (i === 0) canvasCtx.moveTo(pt.x * w, pt.y * h);
                else canvasCtx.lineTo(pt.x * w, pt.y * h);
            }
            canvasCtx.stroke();
        }
    }

    function onResults(results) {
        if (canvasElement.width !== window.innerWidth) {
            canvasElement.width = 480; 
            canvasElement.height = 360; 
        }

        // 背景を黒で塗りつぶし（ビデオ描画を省略）
        canvasCtx.fillStyle = '#000';
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
        
        let targetHand = null;
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            let highestY = 1.1;
            for (const lm of results.multiHandLandmarks) {
                if (lm[8].y < lm[0].y && lm[0].y < highestY) {
                    highestY = lm[0].y;
                    targetHand = lm;
                }
            }
        }

        if (targetHand) {
            drawSkeleton(targetHand);
            const wristY = targetHand[0].y;

            if (!gameStarted && !isPostGameDelay) {
                if (!isReadyToStart && wristY < 0.35) isReadyToStart = true;
                else if (isReadyToStart && wristY > 0.5) { isReadyToStart = false; startGame(); }
                if (isReadyToStart) { statusText.innerText = "HAND DOWN!"; return; }
            }

            // 指の距離計算（軽量版）
            const getDist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
            const wrist = targetHand[0];
            const isI = getDist(targetHand[8], wrist) > getDist(targetHand[6], wrist);
            const isM = getDist(targetHand[12], wrist) > getDist(targetHand[10], wrist);
            const isR = getDist(targetHand[16], wrist) > getDist(targetHand[14], wrist);
            const isP = getDist(targetHand[20], wrist) > getDist(targetHand[18], wrist);

            let handType = 0, label = "なし";
            if (isI && isM && isR && isP) { handType = 1; label = "パー"; }
            else if (isI && isM && !isR && !isP) { handType = 2; label = "チョキ"; }
            else if (!isI && !isM && !isR && !isP) { handType = 3; label = "グー"; }

            statusText.innerText = label;

            if (gameStarted && !isProcessingCorrect && handType !== 0) {
                if (handType === getTaskType(currentTask) && lastHandState !== handType) {
                    isProcessingCorrect = true; score++;
                    playBeep();
                    scoreText.innerText = `Score: ${score}`;
                    centerMsg.innerText = "GOOD!";
                    promptImg.src = "10.jpg";
                    setTimeout(() => { 
                        if (gameStarted) centerMsg.innerText = ""; 
                        isProcessingCorrect = false; nextQuestion(); 
                    }, 500);
                }
                lastHandState = handType;
            }
        } else {
            statusText.innerText = "---";
        }
    }

    const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
    hands.setOptions({
        maxNumHands: 1, 
        modelComplexity: 0, // 最軽量モデル
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 360, height: 480 // 低解像度で負荷軽減
    });
    camera.start();

    function startGame() {
        if (gameStarted || isPostGameDelay) return;
        gameStarted = true; score = 0; timeLeft = 60;
        scoreText.innerText = `Score: ${score}`;
        centerMsg.innerText = "";
        speak("スタート");
        nextQuestion();
        gameTimer = setInterval(() => {
            timeLeft--;
            timerText.innerText = `Time: ${timeLeft}`;
            if (timeLeft <= 0) endGame();
        }, 1000);
    }

    function endGame() {
        gameStarted = false; clearInterval(gameTimer);
        centerMsg.innerHTML = `FINISH!<br>Score: ${score}`;
        speak(`${score}点です。`);
        isPostGameDelay = true;
        setTimeout(() => {
            isPostGameDelay = false;
            centerMsg.innerText = "HAND UP TO START";
            promptImg.src = "0.jpg";
        }, 3000);
    }
</script>
</body>
</html>